set noswapfile

" FOR VUNDLE
set nocompatible               " be iMproved
filetype off                   " required!

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" ----------------------------------------------------------------------------
"  Text Formatting
" ----------------------------------------------------------------------------

set autoindent             " automatic indent new lines
set smartindent            " be smart about it
inoremap # X<BS>#
set nowrap                 " do not wrap lines
set softtabstop=2          " yep, two
set shiftwidth=2           " ..
set tabstop=4
set expandtab              " expand tabs to spaces
set nosmarttab             " fuck tabs
set formatoptions+=n       " support for numbered/bullet lists
"set textwidth=80           " wrap at 80 chars by default
set virtualedit=block      " allow virtual edit in visual block ..

au BufReadPost Vagrantfile set syntax=ruby
au BufReadPost *.god set syntax=ruby
au BufNewFile,BufRead *.less set filetype=less
au BufNewFile,BufRead *.json_builder set filetype=ruby
filetype plugin indent on " Enable filetype-specific indenting and plugins

" Pathogen loader
execute pathogen#infect()

" ----------------------------------------------------------------------------
"  Remapping
" ----------------------------------------------------------------------------

" lead with ,
let mapleader = ","

" exit to normal mode with 'jj'
inoremap jj <ESC>


" reflow paragraph with Q in normal and visual mode
nnoremap Q gqap
vnoremap Q gq

" sane movement with wrap turned on
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk
nnoremap <SPACE> <PAGEDOWN>
nnoremap <S-SPACE> <PAGEUP>
nmap / /\v
cmap s/ s/\v

" Switch windows
"nmap <D-]> :maca _cycleWindowsBackwards:<CR> 
nmap <D-'> :maca _cycleWindows:<CR>

" Reload vimrc on edit and a shortcut
nmap <silent> ;v :next $MYVIMRC<CR>
augroup VimReload
  autocmd!
  autocmd BufWritePost $MYVIMRC source $MYVIMRC 
augroup END

" Persistent Undo
if has('persistent_undo') 
  set undofile
  set undodir=$HOME/tmp/.VIM_UNDO_FILES
  set undolevels=5000
endif

" Remember where we left off editing last session
autocmd BufReadPost *
\ if line("'\"") > 1 && line("'\"") <= line("$") 
\| exe "normal! g`\""
\| endif

" ----------------------------------------------------------------------------
"  UI
" ----------------------------------------------------------------------------

set ruler                  " show the cursor position all the time
set noshowcmd              " don't display incomplete commands
set nolazyredraw           " turn off lazy redraw
set number                 " line numbers
set wildmenu               " turn on wild menu
set wildmode=list:longest,full
set ch=2                   " command line height
set backspace=2            " allow backspacing over everything in insert mode
set whichwrap+=<,>,h,l,[,] " backspace and cursor keys wrap to
set shortmess=filtIoOA     " shorten messages
set report=0               " tell us about changes
set nostartofline          " don't jump to the start of line when scrolling
"set wildignore+="tmp/*","coverage/*"

" -----------------------------------------------------------------------------
" IGNORE STUFF
" ----------------------------------------------------------------------------- 

function! Git_Repo_Cdup() " Get the relative path to repo root
    "Ask git for the root of the git repo (as a relative '../../' path)
    let git_top = system('git rev-parse --show-cdup')
    let git_fail = 'fatal: Not a git repository'
    if strpart(git_top, 0, strlen(git_fail)) == git_fail
        " Above line says we are not in git repo. Ugly. Better version?
        return ''
    else
        " Return the cdup path to the root. If already in root,
        " path will be empty, so add './'
        return './' . git_top
    endif
endfunction

function! CD_Git_Root()
    execute 'cd '.Git_Repo_Cdup()
    let curdir = getcwd()
    echo 'CWD now set to: '.curdir
endfunction
nnoremap <LEADER>gr :call CD_Git_Root()<cr>

" Define the wildignore from gitignore. Primarily for CommandT
function! WildignoreFromGitignore()
    silent call CD_Git_Root()
    let gitignore = '.gitignore'
    if filereadable(gitignore)
        let igstring = ''
        for oline in readfile(gitignore)
            let line = substitute(oline, '\s|\n|\r', '', "g")
            if line =~ '^#' | con | endif
            if line == '' | con  | endif
            if line =~ '^!' | con  | endif
            if line =~ '/$' | let igstring .= "," . line . "*" | con | endif
            let igstring .= "," . line
        endfor
        let execstring = "set wildignore=".substitute(igstring,'^,','',"g")
        execute execstring
        echo 'Wildignore defined from gitignore in: '.getcwd()
    else
        echo 'Unable to find gitignore'
    endif
endfunction
nnoremap <LEADER>cti :call WildignoreFromGitignore()<cr>
nnoremap <LEADER>cwi :set wildignore=''<cr>:echo 'Wildignore cleared'<cr>

nmap <leader>gv :call CD_Git_Root()<cr>\|:CommandT app/views<cr>
nmap <leader>gc :call CD_Git_Root()<cr>\|:CommandT app/controllers<cr>
nmap <leader>gm :call CD_Git_Root()<cr>\|:CommandT app/models<cr>
nmap <leader>gj :call CD_Git_Root()<cr>\|:CommandT app/assets/javascripts<cr>
nmap <leader>gy :call CD_Git_Root()<cr>\|:CommandT app/assets/stylesheets<cr>
nmap <leader>gs :call CD_Git_Root()<cr>\|:CommandT spec<cr>
nmap <leader>gt :call CD_Git_Root()<cr>\|:CommandT app/assets/templates<cr>
nmap <leader>gl :call CD_Git_Root()<cr>\|:CommandT app/lib<cr>
nmap <leader>t :call CD_Git_Root()<cr>\|:CommandT <cr>

" ----------------------------------------------------------------------------
" Visual Cues
" ----------------------------------------------------------------------------

set showmatch              " brackets/braces that is
set mat=5                  " duration to show matching brace (1/10 sec)
set incsearch              " do incremental searching
set laststatus=2           " always show the status line
set smartcase ignorecase   " ignore case when searching unles theres a capital letter
set nohlsearch             " don't highlight searches
set visualbell             " shut the fuck up


" ---------------------------------------------------------------------------
"  Strip all trailing whitespace in file
" ---------------------------------------------------------------------------

function! StripWhitespace ()
    exec ':%s/ \+$//gc'
endfunction
map ,s :call StripWhitespace ()<CR>


Bundle 'YouCompleteMe'
